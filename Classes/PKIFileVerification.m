/*
 Frodo, Commodore 64 emulator for the iPhone
 Copyright (C) 2007-2010 Stuart Carnie
 See gpl.txt for license information.
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#import "PKIFileVerification.h"

#if !TARGET_IPHONE_SIMULATOR

#import <Security/Security.h>
#import <CommonCrypto/CommonHMAC.h>

@implementation PKIFileVerification

- (id)initWithCertificateData:(NSData*)data {
	self = [super init];
	
    SecCertificateRef cert = SecCertificateCreateWithData(NULL, (CFDataRef) data);
    if (cert == NULL) {
		return nil;
	}
	
	SecPolicyRef myPolicy = SecPolicyCreateBasicX509();
	
    SecCertificateRef certArray[1] = { cert };
    CFArrayRef myCerts = CFArrayCreate(NULL, (void *)certArray, 1, NULL);
    SecTrustRef myTrust;
    OSStatus status = SecTrustCreateWithCertificates(myCerts, myPolicy, &myTrust);
	CFRelease(myCerts);
	
    SecTrustResultType trustResult;
    if (status == noErr) {
        status = SecTrustEvaluate(myTrust, &trustResult);       
    }
	
	//Get time used to verify trust
    CFAbsoluteTime trustTime,currentTime,timeIncrement,newTime;
	if (trustResult == kSecTrustResultRecoverableTrustFailure) {
		trustTime = SecTrustGetVerifyTime(myTrust);
        timeIncrement = 31536000;
        currentTime = CFAbsoluteTimeGetCurrent();
        newTime = currentTime - timeIncrement;
        if (trustTime - newTime) {
            CFDateRef newDate = CFDateCreate(NULL, newTime);
            SecTrustSetVerifyDate(myTrust, newDate);
            status = SecTrustEvaluate(myTrust, &trustResult);
			CFRelease(newDate);
		}
	}
	
	publicKey = SecTrustCopyPublicKey(myTrust);
	
	CFRelease(cert);
	CFRelease(myTrust);
	CFRelease(myPolicy);
	return self;
}

- (id)initWithCertificate:(NSString*)fileName {
    NSString *          cerPath;
    NSData *            cerData;
	
    cerPath = [[NSBundle mainBundle] pathForResource:fileName ofType:nil];
    assert(cerPath != nil);

	cerData = [NSData dataWithContentsOfFile:cerPath];
    assert(cerData != nil);

	self = [self initWithCertificateData:cerData];
	
	return self;
}

-(NSData*)generateSHA1FromData:(NSData*)data {
	unsigned char *sha1 = (unsigned char *)malloc(CC_SHA1_DIGEST_LENGTH);
	CC_SHA1([data bytes], [data length], sha1);
	return [NSData dataWithBytesNoCopy:sha1 length:CC_SHA1_DIGEST_LENGTH freeWhenDone:YES];
}

-(NSData*)generateSHA1FromFile:(NSString*)fileName {
	NSData *fileData = [NSData dataWithContentsOfFile:fileName];
	return [self generateSHA1FromData:fileData];
}

- (BOOL)verifyFile:(NSString*)fileName withSignature:(NSString*)signatureFileName {
	NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
	OSStatus status = noErr;
	
	// .sign generated by: openssl sha1 -sign ~/tmp/iPhone.pem -out International\ Karate.sign International\ Karate.d64
    NSData *signatureData = [NSData dataWithContentsOfFile:signatureFileName];
	NSData *sha1 = [self generateSHA1FromFile:fileName];
	status = SecKeyRawVerify(publicKey, kSecPaddingPKCS1SHA1, [sha1 bytes], [sha1 length], [signatureData bytes], [signatureData length]);
	[pool release];	
	return status == noErr;
}

- (BOOL)verifyData:(NSData*)data withSignature:(NSData*)signatureData {
	NSData *sha1 = [self generateSHA1FromData:data];
	OSStatus status = SecKeyRawVerify(publicKey, kSecPaddingPKCS1SHA1, [sha1 bytes], [sha1 length], [signatureData bytes], [signatureData length]);
	return status == noErr;
}

- (void)dealloc {
	CFRelease(publicKey);
	[super dealloc];
}

#else

@implementation PKIFileVerification

- (id)initWithCertificateData:(NSData*)data {
	self = [super init];
	return self;
}

- (id)initWithCertificate:(NSString*)fileName {
	self = [super init];
	
	return self;
}

- (BOOL)verifyFile:(NSString*)fileName withSignature:(NSString*)signatureFileName {
	return YES;
}

- (BOOL)verifyData:(NSData*)data withSignature:(NSData*)signatureData {
	return YES;
}

#endif
@end
